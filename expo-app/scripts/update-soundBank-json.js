const fs = require("fs");
const path = require("path");

// Path to the directory containing your song files
const songsDirectoryRelative = "../generated/sfx";
const songsDirectory = path.join(__dirname, songsDirectoryRelative);

// Path to the JSON file that will store the soundBank
const soundbankFile = path.join(__dirname, "../generated", "soundBank.json");

const loadExistingSoundbank = (filepath) => {
  if (fs.existsSync(filepath)) {
    const data = fs.readFileSync(filepath, "utf8");
    return JSON.parse(data);
  }
  return [];
};

const getAllMp3Files = (dir, fileList = []) => {
  const files = fs.readdirSync(dir);
  files.forEach((file) => {
    const filePath = path.join(dir, file);
    if (fs.statSync(filePath).isDirectory()) {
      getAllMp3Files(filePath, fileList);
    } else if (filePath.endsWith(".mp3")) {
      fileList.push(filePath);
    } else if (filePath.endsWith(".wav")) {
      fileList.push(filePath);
    }
  });
  return fileList;
};

const generateSoundbank = (directory, existingSoundbank) => {
  const soundbank = [...existingSoundbank];
  const songFiles = getAllMp3Files(directory);

  const existingFiles = new Set(soundbank.map((sound) => sound.file));

  // remove any songs that no longer exist
  soundbank.forEach((sound, index) => {
    if (!fs.existsSync(path.join(__dirname, sound.file))) {
      console.log("splicing", sound.file);
      soundbank.splice(index, 1);
    }
  });

  songFiles.forEach((filePath, index) => {
    const relativePath = path.relative(__dirname, filePath);
    if (!existingFiles.has(relativePath)) {
      let nextId = 0;
      while (soundbank.find((sound) => sound.id === nextId)) {
        nextId++;
      }
      soundbank.push({
        id: nextId,
        name: path.basename(filePath, path.extname(filePath)), // Use the file name without extension
        file: relativePath,
        path: relativePath,
        baseVolume: 1.0, // Default baseVolume
      });
    }
  });

  return soundbank;
};

const saveSoundbank = (soundbank, filepath) => {
  const dir = path.dirname(filepath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(filepath, JSON.stringify(soundbank, null, 4), "utf8");
};

function updateImportableJSFile() {
  // load JSON file
  const soundbank = loadExistingSoundbank(soundbankFile);
  // convert to JS
  let js = `
  /*
  *
  * This file is auto-generated by the update-soundBank-json.js script.
  * Do not modify this file directly.
  * To update the soundBank, modify soundBank.json and then run the script with to generate this .js file.
  * 
  */
  export default ${JSON.stringify(soundbank, null, 2)};`;
  // write to file
  //     "file": "../assets/songs/Secret of Evermore OST - Hall of Colosia (Extended) [IcWGih3nojI].mp3",
  js = js.replaceAll(/"file": "(.*?)"/g, '"file": require("$1")');
  const importableFile = path.join(__dirname, "../generated", "soundBank.js");
  fs.writeFileSync(importableFile, js, "utf8");
}

const main = () => {
  const existingSoundbank = loadExistingSoundbank(soundbankFile);
  /* If we uncomment this code then we will try to not clobber the existing soundBank.json
  This allows us to manually modify some things like the name and volume for the sound
  however, I'm moving away from thinking we should maintain the json file and instead
  we should just modify the mp3 files themselves! So we can overwrite the JSON each time no problem. */
  const updatedSoundbank = generateSoundbank(songsDirectory, []);
  saveSoundbank(updatedSoundbank, soundbankFile);
  console.log(`SoundBank updated with ${updatedSoundbank.length} songs.`);
  updateImportableJSFile();
};

main();
